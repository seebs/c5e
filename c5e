#!/usr/bin/ruby -w

# The actual pretty-printing page:
base_template = <<'EOF'
doctype html
html
  head
    title = "#{name}"
    style type="text/css" == css
  body
    .content
      h2 The #{name.capitalize}
      == markdown(flavortext)
      h3 Creating a #{name.capitalize}
      markdown:
        #{creating_a}
      h4 Quick Build
      p To create a #{name}, put your best score in
	#{quick_build[0].capitalize}, your second-best in
	#{quick_build[1].capitalize}, and take the
	#{quick_build[2].capitalize} background.

    table.classtable
      tr
        th Level
	th =="Proficiency<br/>Bonus"
	th Features
      - for level in (1..20)
        tr
          td.c =level.ordinalize
	  td.c ="+#{proficiency(level)}"
	  td =features_by_level[level].join(", ")
    .content
      h2 Class Features
      p As a #{name}, you gain the following class features.
      h4 Hit Points
      markdown:
        **Hit Dice:** 1d#{hitdie} per #{name} level  
        **Hit Points at 1st Level:** #{hitdie} + your Constitution modifier  
        **Hit Points at Higher Levels:** 1d#{hitdie} (or #{hitdie_average}) + your Constitution modifier per #{name} level after 1st
      h4 Proficiencies
      markdown:
        **Armor:** #{proficiency_armor.capitalize}  
        **Weapons:** #{proficiency_weapons.capitalize}  
        **Tools:** #{proficiency_tools.capitalize}  
	  
	**Saving Throws:** #{proficiency_saves.capitalize}  
	**Skills:** Choose #{proficiency_skills_choose} from #{proficiency_skills_list.map(&:capitalize).join(", ")}

      h4 Equipment
      p Sample stuff.
      ul
        - for item in equipment
          li == markdown(item)
	   
      - for level in (1..20)
        - for feature in features_by_level[level]
	  - if !already_displayed[feature]
	    - already_displayed[feature] = true
	    h3 =feature
	    markdown:
	      #{features_by_name[feature]}
	 
EOF

default_css_data = <<'EOF'
body {
    background-color: #ffffff;
    color: #202020;
    font-family: "Libra Baskerville", Baskerville, serif;
    text-align: left;
}

p {
  margin-bottom: 0.1em;
  margin-top: 0.1em;
}

h2, h3, h4 {
  font-variant: small-caps;
  font-weight: normal;
}

h2 {
  color: #600;
  margin-bottom: 0.1em;
}

h3 {
  color: #600;
  border-bottom: 1px solid;
  margin-bottom: 0.1em;
}

h4 {
  color: #600;
  margin-bottom: 0em;
  margin-top: 0.5em;
}

ul, ol {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

a {
    color: #0000a0;
    text-decoration: none;
}

td.c {
  text-align: center;
}

p.hang {
  padding-left: 1em;
  text-indent: -1em;
  margin-bottom: 0em;
  margin-top: 0em;
}

a:active {
    color:  #0000ff;
    text-decoration: underline;
}

a:visited {
    color:  #500090;
}

table.classtable {
  min-width: 50%;
  border-collapse: collapse;
}

table.classtable tr td, th {
  border-color: inherit;
  border-style: none solid;
  margin: 2pt;
}

table.classtable tr:nth-child(even) {
  background-color: #cccccc;
  border-color: #cccccc;
}

table.classtable tr:nth-child(odd) {
  background-color: #ffffff;
  border-color: #ffffff;
}

th {
  text-align: center;
}

a:hover {
    color: #0000ff;
    text-decoration: underline;
}

div.description {
}

div.illo {
    float: right;
    clear: right;
    display: inline;
    margin-left: .1em;
}
EOF

require 'yaml'
require 'slim'
require 'optparse'
require 'redcarpet'
require 'active_support/core_ext/integer/inflections'

Slim::Engine.set_default_options pretty: true, sort_attrs: false, tabsize: 8

def note(message)
  STDERR.puts message
end

options = {}

OptionParser.new do |opts|
  opts.banner = "Usage: c5e [-c css] classname"
  opts.on("-cMANDATORY", String, "select css file") do |v|
    options[:css] = v
  end
end.parse!

slim_template = Slim::Template.new { base_template }

if options[:css] then
  default_css_data = begin
    File.read(options[:css])
  rescue Errno::ENOENT
    begin
      File.read(options[:css] + ".css")
    rescue Errno::ENOENT
      note "Couldn't find a css file named '#{options[:css]}'."
      nil
    end
  else
    note "Couldn't find a css file named '#{options[:css]}'."
    nil
  end
end

fields = %i(
  version
  name
  hitdie
  abilityincreases
  casting
  features
  extra_features
  proficiency_armor
  proficiency_weapons
  proficiency_skills
  proficiency_saves
  proficiency_tools
  equipment
  flavortext
  creating_a
  quick_build
  archetypes
  css
)

ClassSpec = Struct.new(*fields)

class ClassSpec
  @@internal_members = %i(features_by_name features_by_level proficiency_skills_choose proficiency_skills_list hitdie_average already_displayed)
  @@internal_members.each do |m| attr_accessor m end
  def initialize(filename, hash)
    @filename = filename
    @markdown = Redcarpet::Markdown.new(Redcarpet::Render::XHTML, {})
    missing = []
    extra = []
    members.each do |m|
      obj = hash[m] || hash[m.to_s]
      hash.delete(m)
      hash.delete(m.to_s)
      if obj then
	if obj.respond_to? :keys then
	  obj = OpenStruct.new(obj)
	end
        send("#{m}=", obj)
      else
        missing << m
      end
    end
    @@internal_members.each do |m|
      self.send("#{m}=", hash[m] || hash[m.to_s])
      hash.delete(m)
      hash.delete(m.to_s)
    end
    hash.each do |k,v|
      extra << k
    end
    if !missing.empty?
      note "Missing fields: #{missing.join(', ')}"
    end
    if !extra.empty?
      note "Extra fields: #{extra.join(', ')}"
    end
  end

  def fatal(message)
    note "Fatal error in '#{@filename}': #{message}"
    @failed = true
  end

  def set_default(name, value)
    if !send(name)
      send(name + "=", value)
    end
  end

  def proficiency(n)
    ((n+7)/4).floor
  end

  def markdown(text)
    @markdown.render(text)
  end

  def full_capitalize(str)
    str.split.map(&:capitalize).join(' ')
  end

  def sanity
    @failed = false
    if !name
      fatal "No name defined."
    end
    if !abilityincreases
      self.abilityincreases = [ 4, 8, 12, 16, 19 ]
    end
    abilityincreases.sort!
    if !hitdie
      fatal "You must specify hit die type (for example, 8 or d8)."
    else
      self.hitdie = hitdie.sub('d', '').to_i
      if !hitdie or hitdie <= 0
        fatal "Hit die must be a positive number."
      end
      self.hitdie_average = (hitdie / 2).floor + 1
    end
    self.features_by_level = Hash.new { |h,k| h[k] = [] }
    self.features_by_name = Hash.new
    features.each do |f|
      name = full_capitalize(f['name'])
      level = f['level'].to_i
      features_by_level[level] << name
      features_by_name[name] = f['description']
    end
    abilityincreases.each do |level|
      features_by_level[level] << "Ability Score Improvement"
    end
    first = abilityincreases[0]
    last = abilityincreases[-1]
    rest = abilityincreases[1..-2]
    features_by_name['Ability Score Improvement'] = <<EOF
When you reach #{first.ordinalize} level, and again at
#{rest.map(&:ordinalize).join(", ")}, and #{last.ordinalize} level,
you can increase one ability score by 2, or two ability scores by 1,
to a maximum of 20.
EOF
    set_default('proficiency_skills', ["one", "basket-weaving", "exploding"])
    set_default('proficiency_armor', 'none')
    set_default('proficiency_weapons', 'none')
    set_default('proficiency_tools', 'none')
    set_default('proficiency_saves', 'none')
    self.proficiency_skills_choose = proficiency_skills[0]
    self.proficiency_skills_list = proficiency_skills[1..-1]
    self.already_displayed = Hash.new
    equipment.each_index do |i|
      obj = equipment[i]
      if obj.respond_to? :each_index
        newlist = []
	obj.each_index do |j|
	  o = obj[j]
	  let = 'abcdefghijklmnop'[j]
	  newlist << "*(#{let})* #{o}"
	end
	equipment[i] = newlist.join(", or ")
      end
    end
    !@failed
  end

  def prettyprint(template)
    note "Found data for #{name}"
    htmlname = if @filename['.yaml'] then
      @filename.sub('.yaml', '.html')
    else
      @filename + '.html'
    end
    @htmlfile = File.open(htmlname, "w")
    @htmlfile.puts(template.render(self))
  end
end

ARGV.each do |arg|
  if not File.exist?(arg)
    if File.exist?("#{arg}.yaml")
      arg = "#{arg}.yaml"
    else
      note "Can't open '#{arg}'."
      next
    end
  end
  data = YAML.load_file(arg)
  if data then
    if not data['css']
      data['css'] = default_css_data
    end
    wrapped = ClassSpec.new(arg, data)
    if wrapped.sanity
      wrapped.prettyprint(slim_template)
    end
  else
    note "Failed to load '#{arg}'."
  end
end
